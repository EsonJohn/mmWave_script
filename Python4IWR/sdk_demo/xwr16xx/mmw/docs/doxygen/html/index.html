<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Millimeter Wave (mmw) Demo for XWR16XX</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Millimeter Wave (mmw) Demo for XWR16XX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<div class="image">
<img src="toplevel.png" alt="toplevel.png"/>
</div>
<p>The millimeter wave demo shows some of the capabilities of the XWR16xx SoC using the drivers in the mmWave SDK (Software Development Kit). It allows user to specify the chirping profile and displays the detected objects and other information in real-time.</p>
<p>Following is a high level description of the features of this demo:</p><ul>
<li>Be able to specify desired chirping profile through command line interface (CLI) on a UART port or through the TI Gallery App - <b>mmWave Demo Visualizer</b> - that allows user to provide a variety of profile configurations via the UART input port and displays the streamed detected output from another UART port in real-time, as seen in picture above.</li>
<li>Some sample profile configurations have been provided in the demo directory that can be used with CLI directly or via <b>mmWave Demo Visualizer</b> under following directory: <pre class="fragment">mmw/profiles </pre>.</li>
<li>Do 1D, 2D, CFAR, and Azimuth processing and stream out velocity and two spatial coordinates (x,y) of the detected objects in real-time.</li>
<li>Various display options besides object detection like azimuth heat map and Doppler-range heat map.</li>
</ul>
<h1><a class="anchor" id="limit"></a>
Limitations</h1>
<ul>
<li>Because of UART speed limit (&lt; 1 Mbps), the frame time is more restrictive. For example, for the azimuth and Doppler heat maps for 256 FFT range and 16 point FFT Doppler, it takes about 200 ms to transmit.</li>
<li>For most boards, a range bias of few centimeters has been observed. User can estimate the range bias on their board and correct using the calibration procedure described in <a class="el" href="index.html#Calibration_section">Range Bias and Rx Channel Gain/Phase Measurement and Compensation</a>.</li>
</ul>
<h1><a class="anchor" id="systemFlow"></a>
System Execution Flow</h1>
<p>The millimeter wave demo runs on R4F (MSS) and C674x (DSS). Following diagram shows the system execution flow</p>
<div class="image">
<img src="system_flow.png" alt="system_flow.png"/>
<div class="caption">
System Execution Flow</div></div>
 <h1><a class="anchor" id="tasks"></a>
Software Tasks</h1>
<p>The demo consists of the following (SYSBIOS) tasks:</p>
<p><b>MSS</b></p><ul>
<li><a class="el" href="mss__main_8c.html#a827e7512197324c4f0b9eecec8efff02">MmwDemo_initTask</a>. This task is created/launched by <a class="el" href="mss__main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> and is a one-time active task whose main functionality is to initialize drivers (&lt;driver&gt;_init), MMWave module (MMWave_init), DPM module (DPM_init), open UART and data path related drivers (ADCBUF), and create/launch the following tasks (the <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/utils/cli/docs/cli.tag:../../../../../../utils/cli/docs/doxygen/html/" href="../../../../../../utils/cli/docs/doxygen/html/group___c_l_i___u_t_i_l___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a> is launched indirectly by calling <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/utils/cli/docs/cli.tag:../../../../../../utils/cli/docs/doxygen/html/" href="../../../../../../utils/cli/docs/doxygen/html/group___c_l_i___u_t_i_l___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga664861a70519c2c7c5e4091b1a0958f2">CLI_open</a>).</li>
<li><a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/utils/cli/docs/cli.tag:../../../../../../utils/cli/docs/doxygen/html/" href="../../../../../../utils/cli/docs/doxygen/html/group___c_l_i___u_t_i_l___i_n_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga96a82b05d16ca58d5c4f7ade7f0df74f">CLI_task</a>. This command line interface task provides a simplified 'shell' interface which allows the configuration of the BSS via the mmWave interface (MMWave_config). It parses input CLI configuration commands like chirp profile and GUI configuration. When sensor start CLI command is parsed, all actions related to starting sensor and starting the processing the data path are taken. When sensor stop CLI command is parsed, all actions related to stopping the sensor and stopping the processing of the data path are taken</li>
<li><a class="el" href="mss__main_8c.html#a2c488875d2aa01e3f1ba45108ce9f2ef">MmwDemo_mmWaveCtrlTask</a>. This task is used to provide an execution context for the mmWave control, it calls in an endless loop the MMWave_execute API.</li>
<li><a class="el" href="mss__main_8c.html#ab749df82df883d14fe1f8e1700789560">mmwDemo_mssDPMTask</a>. This task is used to provide an execution context for DPM (Data Path Manager) execution, it calls in an endless loop. There is no DPC registered with DPM.</li>
</ul>
<p><b>DSS</b></p><ul>
<li><a class="el" href="mss__main_8c.html#a827e7512197324c4f0b9eecec8efff02">MmwDemo_initTask</a>. This task is created/launched by <a class="el" href="mss__main_8c.html#a840291bc02cba5474a4cb46a9b9566fe">main</a> and is a one-time active task whose main functionality is to initialize drivers (&lt;driver&gt;_init), DPM module (DPM_init), data path related drivers (EDMA), and create/launch the following tasks.</li>
<li><a class="el" href="dss__main_8c.html#a6f404d4ba8b95e3cb6eb4add70be54a9">MmwDemo_DPC_ObjectDetection_dpmTask</a>. This task is used to provide an execution context for DPM (Data Path Manager) execution, it calls in an endless loop the DPM_execute API. In this context, all of the registered object detection DPC (Data Path Chain) APIs like configuration, control and execute will take place. In this task. When the DPC's execute API produces the detected objects and other results, they are reported to MSS where they are transmitted out of the UART port for display using the visualizer.</li>
</ul>
<h1><a class="anchor" id="datapath"></a>
Data Path</h1>
<div class="image">
<img src="datapath_overall.png" alt="datapath_overall.png"/>
<div class="caption">
Top Level Data Path Processing Chain</div></div>
<p> <br />
 <br />
 </p><div class="image">
<img src="datapath_overall_timing.png" alt="datapath_overall_timing.png"/>
<div class="caption">
Top Level Data Path Timing</div></div>
<p> The data path processing consists of taking ADC samples as input and producing detected objects (point-cloud and other information) to be shipped out of UART port to the PC. The algorithm processing is realized using the DPM registered Object Detection DPC. The details of the processing in DPC can be seen from the following doxygen documentation: </p><pre class="fragment">  ti/datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/index.html</pre><h2><a class="anchor" id="output"></a>
Output information sent to host</h2>
<p>Output packets with the detection information are sent out every frame through the UART. Each packet consists of the header <a class="el" href="struct_mmw_demo__output__message__header__t.html">MmwDemo_output_message_header_t</a> and the number of TLV items containing various data information with types enumerated in <a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314">MmwDemo_output_message_type_e</a>. The numerical values of the types can be found in <a class="el" href="mmw__output_8h.html">mmw_output.h</a>. Each TLV item consists of type, length (<a class="el" href="struct_mmw_demo__output__message__tl__t.html">MmwDemo_output_message_tl_t</a>) and payload information. The structure of the output packet is illustrated in the following figure. Since the length of the packet depends on the number of detected objects it can vary from frame to frame. The end of the packet is padded so that the total packet length is always multiple of 32 Bytes.</p>
<div class="image">
<img src="output_packet_uart.png" alt="output_packet_uart.png"/>
<div class="caption">
Output packet structure sent to UART</div></div>
<p> The following subsections describe the structure of each TLV.</p>
<h3><a class="anchor" id="tlv1"></a>
List of detected objects</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314ac896a2017ffbe63bf6bae47604ac3094">MMWDEMO_OUTPUT_MSG_DETECTED_POINTS</a>)</p>
<p>Length: (Number of detected objects) x (size of <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a>)</p>
<p>Value: Array of detected objects. The information of each detected object is as per the structure <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a>. When the number of detected objects is zero, this TLV item is not sent. The maximum number of objects that can be detected in a sub-frame/frame is <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/objectdetection/objdetdsp/docs/objdetdsp.tag:../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/" href="../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/objectdetection_8c.html#acc21bf75d7659447df554afa64ae0bc6">DPC_OBJDET_MAX_NUM_OBJECTS</a>.</p>
<p>The orientation of x,y and z axes relative to the sensor is as per the following figure.</p>
<div class="image">
<img src="coordinate_geometry.png" alt="coordinate_geometry.png"/>
<div class="caption">
Coordinate Geometry</div></div>
<p> The whole detected objects TLV structure is illustrated in figure below.</p>
<div class="image">
<img src="detected_objects_tlv.png" alt="detected_objects_tlv.png"/>
<div class="caption">
Detected objects TLV</div></div>
 <h3><a class="anchor" id="tlv2"></a>
Range profile</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314a8379a0f322cdf98d72de0d29c613972b">MMWDEMO_OUTPUT_MSG_RANGE_PROFILE</a>)</p>
<p>Length: (Range FFT size) x (size of uint16_t)</p>
<p>Value: Array of profile points at 0th Doppler (stationary objects). The points represent the sum of log2 magnitudes of received antennas expressed in Q9 format.</p>
<h3><a class="anchor" id="tlv3"></a>
Noise floor profile</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314a2f22cc4380702439ad5d161154daa135">MMWDEMO_OUTPUT_MSG_NOISE_PROFILE</a>)</p>
<p>Length: (Range FFT size) x (size of uint16_t)</p>
<p>Value: This is the same format as range profile but the profile is at the maximum Doppler bin (maximum speed objects). In general for stationary scene, there would be no objects or clutter at maximum speed so the range profile at such speed represents the receiver noise floor.</p>
<h3><a class="anchor" id="tlv4"></a>
Azimuth static heatmap</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314aa9eb23150e2b2e0a4d4dd0483250648d">MMWDEMO_OUTPUT_MSG_AZIMUT_STATIC_HEAT_MAP</a>)</p>
<p>Length: (Range FFT size) x (Number of virtual antennas) (size of <a class="el" href="structcmplx16_im_re__t__.html">cmplx16ImRe_t_</a>)</p>
<p>Value: Array <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/aoaproc/docs/aoaproc.tag:../../../../../../datapath/dpc/dpu/aoaproc/docs/doxygen/html/" href="../../../../../../datapath/dpc/dpu/aoaproc/docs/doxygen/html/struct_d_p_u___ao_a_proc_d_s_p___resources__t.html#a66991b11975301d65842b8f221c08705">DPU_AoAProcDSP_HW_Resources::azimuthStaticHeatMap</a>. The antenna data are complex symbols, with imaginary first and real second in the following order:<br />
</p><pre class="fragment">         Imag(ant 0, range 0), Real(ant 0, range 0),...,Imag(ant N-1, range 0),Real(ant N-1, range 0)
         ...
         Imag(ant 0, range R-1), Real(ant 0, range R-1),...,Imag(ant N-1, range R-1),Real(ant N-1, range R-1)</pre><p> Based on this data the static azimuth heat map is constructed by the GUI running on the host.</p>
<h3><a class="anchor" id="tlv5"></a>
Range/Doppler heatmap</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314aa27e45d8b27b239cd9cf30e95b616822">MMWDEMO_OUTPUT_MSG_RANGE_DOPPLER_HEAT_MAP</a>)</p>
<p>Length: (Range FFT size) x (Doppler FFT size) (size of uint16_t)</p>
<p>Value: Detection matrix <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___det_matrix__t.html#a8c388fc53f78946e8b642ac45cb20162">DPIF_DetMatrix::data</a>. The order is : <br />
</p><pre class="fragment">        X(range bin 0, Doppler bin 0),...,X(range bin 0, Doppler bin D-1),
        ...
        X(range bin R-1, Doppler bin 0),...,X(range bin R-1, Doppler bin D-1)</pre><h3><a class="anchor" id="tlv6"></a>
Stats information</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314ae2e666ace315e23b261eb87cacc225b5">MMWDEMO_OUTPUT_MSG_STATS</a> )</p>
<p>Length: (size of <a class="el" href="struct_mmw_demo__output__message__stats__t.html">MmwDemo_output_message_stats_t</a>)</p>
<p>Value: Timing information as per <a class="el" href="struct_mmw_demo__output__message__stats__t.html">MmwDemo_output_message_stats_t</a>. See timing diagram below related to the stats.</p>
<div class="image">
<img src="processing_timing.png" alt="processing_timing.png"/>
<div class="caption">
Processing timing</div></div>
<p> Note:</p><ol type="1">
<li>While the <a class="el" href="struct_mmw_demo__output__message__stats__t.html#ac8b4b9aeaa00c53733f20522a7e9f5aa">MmwDemo_output_message_stats_t::interFrameProcessingTime</a> reported will be of the current sub-frame/frame, the <a class="el" href="struct_mmw_demo__output__message__stats__t.html#a7fef71cb96826799c0eafb7cb4cc1b60">MmwDemo_output_message_stats_t::interFrameProcessingMargin</a> and <a class="el" href="struct_mmw_demo__output__message__stats__t.html#affed36a79b13398fb36f29e3e14fa4ee">MmwDemo_output_message_stats_t::transmitOutputTime</a> will be of the previous sub-frame (of the same <a class="el" href="struct_mmw_demo__output__message__header__t.html#a5365806acdcde0be962414d8305ab31d">MmwDemo_output_message_header_t::subFrameNumber</a> as that of the current sub-frame) or of the previous frame.</li>
<li>The <a class="el" href="struct_mmw_demo__output__message__stats__t.html#a7fef71cb96826799c0eafb7cb4cc1b60">MmwDemo_output_message_stats_t::interFrameProcessingMargin</a> excludes the UART transmission time (available as <a class="el" href="struct_mmw_demo__output__message__stats__t.html#affed36a79b13398fb36f29e3e14fa4ee">MmwDemo_output_message_stats_t::transmitOutputTime</a>). This is done intentionally to inform the user of a genuine inter-frame processing margin without being influenced by a slow transport like UART, this transport time can be significantly longer for example when streaming out debug information like heat maps. Also, in a real product deployment, higher speed interfaces (e.g LVDS) are likely to be used instead of UART. User can calculate the margin that includes transport overhead (say to determine the max frame rate that a particular demo configuration will allow) using the stats because they also contain the UART transmission time.</li>
</ol>
<p>The CLI command "guMonitor" specifies which TLV element will be sent out within the output packet. The arguments of the CLI command are stored in the structure <a class="el" href="struct_mmw_demo___gui_mon_sel__t.html">MmwDemo_GuiMonSel_t</a>.</p>
<h3><a class="anchor" id="tlv7"></a>
Side information of detected objects</h3>
<p>Type: (<a class="el" href="mmw__output_8h.html#ab645b80e5578dfb3602b52f012594314ac313477cc6aba88fa75718a354348db6">MMWDEMO_OUTPUT_MSG_DETECTED_POINTS_SIDE_INFO</a>)</p>
<p>Length: (Number of detected objects) x (size of <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_side_info__t.html">DPIF_PointCloudSideInfo_t</a>)</p>
<p>Value: Array of detected objects side information. The side information of each detected object is as per the structure <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_side_info__t.html">DPIF_PointCloudSideInfo_t</a>). When the number of detected objects is zero, this TLV item is not sent.</p>
<h2><a class="anchor" id="Calibration_section"></a>
Range Bias and Rx Channel Gain/Phase Measurement and Compensation</h2>
<p>Because of imperfections in antenna layouts on the board, RF delays in SOC, etc, there is need to calibrate the sensor to compensate for bias in the range estimation and receive channel gain and phase imperfections. The following figure illustrates the calibration procedure.</p>
<p><a class="anchor" id="Figure_calibration_ladder_diagram"></a> </p><div class="image">
<img src="calibration_ladder_diagram.png" alt="calibration_ladder_diagram.png"/>
<div class="caption">
Calibration procedure ladder diagram</div></div>
<p> The calibration procedure includes the following steps:</p><ol type="1">
<li>Set a strong target like corner reflector at the distance of X meter (X less than 50 cm is not recommended) at boresight.</li>
<li>Set the following command in the configuration profile in .../profiles/profile_calibration.cfg, to reflect the position X as follows: <pre class="fragment">   measureRangeBiasAndRxChanPhase 1 X D</pre> where D (in meters) is the distance of window around X where the peak will be searched. The purpose of the search window is to allow the test environment from not being overly constrained say because it may not be possible to clear it of all reflectors that may be stronger than the one used for calibration. The window size is recommended to be at least the distance equivalent of a few range bins. One range bin for the calibration profile (profile_calibration.cfg) is about 5 cm. The first argument "1" is to enable the measurement. The stated configuration profile (.cfg) must be used otherwise the calibration may not work as expected (this profile ensures all transmit and receive antennas are engaged among other things needed for calibration).</li>
<li>Start the sensor with the configuration file.</li>
<li>In the configuration file, the measurement is enabled because of which the DPC will be configured to perform the measurement and generate the measurement result (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/dpu/aoaproc/docs/aoaproc.tag:../../../../../../datapath/dpc/dpu/aoaproc/docs/doxygen/html/" href="../../../../../../datapath/dpc/dpu/aoaproc/docs/doxygen/html/struct_d_p_u___ao_a_proc__comp_rx_channel_bias_cfg__t.html">DPU_AoAProc_compRxChannelBiasCfg_t</a>) in its result structure (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/objectdetection/objdetdsp/docs/objdetdsp.tag:../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/" href="../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/struct_d_p_c___object_detection___execute_result__t.html#a1d115a7fd41c8f3998611247d0c800a2">DPC_ObjectDetection_ExecuteResult_t::compRxChanBiasMeasurement</a>), the measurement results are written out on the CLI port (<a class="el" href="mss__main_8c.html#ad6b8a0105f9062b0db109f54011d08d2">MmwDemo_measurementResultOutput</a>) in the format below: <pre class="fragment">   compRangeBiasAndRxChanPhase &lt;rangeBias&gt; &lt;Re(0,0)&gt; &lt;Im(0,0)&gt; &lt;Re(0,1)&gt; &lt;Im(0,1)&gt; ... &lt;Re(0,R-1)&gt; &lt;Im(0,R-1)&gt; &lt;Re(1,0)&gt; &lt;Im(1,0)&gt; ... &lt;Re(T-1,R-1)&gt; &lt;Im(T-1,R-1)&gt;</pre> For details of how DPC performs the measurement, see the DPC documentation.</li>
<li>The command printed out on the CLI now can be copied and pasted in any configuration file for correction purposes. This configuration will be passed to the DPC for the purpose of applying compensation during angle computation, the details of this can be seen in the DPC documentation. If compensation is not desired, the following command should be given <pre class="fragment">   compRangeBiasAndRxChanPhase 0.0   1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0</pre> Above sets the range bias to 0 and the phase coefficients to unity so that there is no correction. Note the two commands must always be given in any configuration file, typically the measure commmand will be disabled when the correction command is the desired one.</li>
</ol>
<h2><a class="anchor" id="bpmCfgNotes"></a>
BPM Scheme</h2>
<p>Similar to TDM-MIMO, in BPM scheme a frame consists of multiple blocks, each block consisting of 2 chirp intervals. However, unlike in TDM-MIMO where only one TX antenna active per chirp interval, both Tx antennas are active in each chirp interval (see figure below).<br />
 </p><div class="image">
<img src="bpm_antenna_cfg.png" alt="bpm_antenna_cfg.png"/>
<div class="caption">
BPM Scheme Antenna configuration</div></div>
<p> Let S1 and S2 represent chirp signals from two Tx antennas. In the first interval a combined signal Sa=S1+S2 is transmitted. Similarly in the second interval a combined signal Sb=S1-S2 is transmitted. Using the corresponding received signals, (S'a and S'b), at a specific received RX antenna, the components from the individual transmitters are separated out using S'1=(S'a+S'b)/2 and S'2=(S'a-S'b)/2.<br />
 With simultaneous transmission on both Tx antennas the total transmitted power per chirp interval is increased, and it can be shown that this translates to an SNR improvement of 3dB.<br />
</p>
<h2><a class="anchor" id="bpmNotes"></a>
AoA DSP DPU changes when BPM is enabled</h2>
<p>When BPM is enabled the following changes are done in the data path. </p>
<h3><a class="anchor" id="BPM_2d"></a>
2D Processing changes for BPM:</h3>
<p>In the 2D processing chain, when BPM is enabled, Doppler compensation and BPM decoding are done after the 2D FFT. Note that the decoded data is not stored in the radar cube, therefore BPM decoding needs to be done again (on a much smaller set of samples) during the direction of arrival computation. The following figure shows the required changes in the 2D processing. When BPM is enabled the fftOut2D buffer is doubled in size to accommodate both Ping (Tx1+Tx2) and Pong (Tx1-Tx2) so that BPM can be decoded.</p>
<div class="image">
<img src="bpm_2d_changes.png" alt="bpm_2d_changes.png"/>
<div class="caption">
2D processing changes for BPM</div></div>
 <h3><a class="anchor" id="BPM_3d"></a>
Direction of Arrival Processing changes for BPM:</h3>
<p>In the direction of arrival processing, when BPM is enabled, Doppler compensation and BPM decoding are done after the 2D FFT and before the azimuth FFT. The following figure shows the required changes in the direction of arrival processing.</p>
<div class="image">
<img src="direction_of_arrival_bpm.png" alt="direction_of_arrival_bpm.png"/>
<div class="caption">
Direction of arrival computation changes for BPM</div></div>
 <h1><a class="anchor" id="LVDSStreamingNotes"></a>
Streaming data over LVDS</h1>
<p>The LVDS streaming feature enables the streaming of HW data (a combination of ADC/CP/CQ data) and/or user specific SW data through LVDS interface. The streaming is done mostly by the CBUFF and EDMA peripherals with minimal CPU intervention. The streaming is configured through the <a class="el" href="struct_mmw_demo___lvds_stream_cfg__t.html">MmwDemo_LvdsStreamCfg_t</a> CLI command which allows control of HSI header, enable/disable of HW and SW data and data format choice for the HW data. The choices for data formats for HW data are:</p><ul>
<li><a class="el" href="mmw__config_8h.html#a670a98798093887e2cf4042f75a78cb4">MMW_DEMO_LVDS_STREAM_CFG_DATAFMT_DISABLED</a></li>
<li><a class="el" href="mmw__config_8h.html#a785b02d1bf4739d1522efb8bc52e4d96">MMW_DEMO_LVDS_STREAM_CFG_DATAFMT_ADC</a></li>
<li><a class="el" href="mmw__config_8h.html#a9d2321accdcaa9ea590295cf655bd421">MMW_DEMO_LVDS_STREAM_CFG_DATAFMT_CP_ADC_CQ</a></li>
</ul>
<p>In order to see the high-level data format details corresponding to the above data format configurations, refer to the corresponding slides in ti\drivers\cbuff\docs\CBUFF_Transfers.pptx</p>
<p>Note:</p><ol type="1">
<li>Only single-chirp formats are allowed, multi-chirp is not supported.</li>
</ol>
<p>When HW data LVDS streaming is enabled, the ADC/CP/CQ data is streamed per chirp on every chirp event. When SW data streaming is enabled, it is streamed during inter-frame period after the list of detected objects for that frame is computed. The SW data streamed every frame/sub-frame is composed of the following in time:</p><ol type="1">
<li>HSI header (<a class="el" href="struct_h_s_i_header__t.html">HSIHeader_t</a>): refer to HSI module for details.</li>
<li>User data header: <a class="el" href="struct_mmw_demo___l_v_d_s_user_data_header.html">MmwDemo_LVDSUserDataHeader</a></li>
<li>User data payloads:<ol type="a">
<li>Point-cloud information as a list : <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_cartesian__t.html">DPIF_PointCloudCartesian_t</a> x number of detected objects</li>
<li>Point-cloud side information as a list : <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpu/rangeproc/docs/rangeproc.tag:../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/" href="../../../../../../datapath/dpu/rangeproc/docs/doxygen/html/struct_d_p_i_f___point_cloud_side_info__t.html">DPIF_PointCloudSideInfo_t</a> x number of detected objects</li>
</ol>
</li>
</ol>
<p>The format of the SW data streamed is shown in the following figure:</p>
<div class="image">
<img src="lvds_sw_data_format.png" alt="lvds_sw_data_format.png"/>
<div class="caption">
LVDS SW Data format</div></div>
<p> Note:</p><ol type="1">
<li>When number of objects detected in frame/sub-frame is 0, there is no transmission beyond the user data header.</li>
<li>For HW data, the inter-chirp duration should be sufficient to stream out the desired amount of data. For example, if the HW data-format is ADC and HSI header is enabled, then the total amount of data generated per chirp is:<br />
 (numAdcSamples * numRxChannels * 4 (size of complex sample) + 52 [sizeof(HSIDataCardHeader_t) + sizeof(HSISDKHeader_t)] ) rounded up to multiples of 256 [=sizeof(HSIHeader_t)] bytes.<br />
 The chirp time Tc in us = idle time + ramp end time in the profile configuration. For n-lane LVDS with each lane at a maximum of B Mbps,<br />
 maximum number of bytes that can be send per chirp = Tc * n * B / 8 which should be greater than the total amount of data generated per chirp i.e<br />
 Tc * n * B / 8 &gt;= round-up(numAdcSamples * numRxChannels * 4 + 52, 256). <br />
 E.g if n = 2, B = 600 Mbps, idle time = 7 us, ramp end time = 44 us, numAdcSamples = 512, numRxChannels = 4, then 7650 &gt;= 8448 is violated so this configuration will not work. If the idle-time is doubled in the above example, then we have 8700 &gt; 8448, so this configuration will work.</li>
<li>For SW data, the number of bytes to transmit each sub-frame/frame is:<br />
 52 [sizeof(HSIDataCardHeader_t) + sizeof(HSISDKHeader_t)] + sizeof(MmwDemo_LVDSUserDataHeader_t) [=8] + <br />
 number of detected objects (Nd) * { sizeof(DPIF_PointCloudCartesian_t) [=16] + sizeof(DPIF_PointCloudSideInfo_t) [=4] } rounded up to multiples of 256 [=sizeof(HSIHeader_t)] bytes.<br />
 or X = round-up(60 + Nd * 20, 256). So the time to transmit this data will be <br />
 X * 8 / (n*B) us. The maximum number of objects (Ndmax) that can be detected is defined in the DPC (<a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/datapath/dpc/objectdetection/objdetdsp/docs/objdetdsp.tag:../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/" href="../../../../../../datapath/dpc/objectdetection/objdetdsp/docs/doxygen/html/objectdetection_8c.html#acc21bf75d7659447df554afa64ae0bc6">DPC_OBJDET_MAX_NUM_OBJECTS</a>). So if Ndmax = 500, then time to transmit SW data is 68 us. Because we parallelize this transmission with the much slower UART transmission, and because UART transmission is also sending at least the same amount of information as the LVDS, the LVDS transmission time will not add any burdens on the processing budget beyond the overhead of reconfiguring and activating the CBUFF session (this overhead is likely bigger than the time to transmit).</li>
<li>The total amount of data to be transmitted in a HW or SW packet must be greater than the minimum required by CBUFF, which is 64 bytes or 32 CBUFF Units (this is the definition CBUFF_MIN_TRANSFER_SIZE_CBUFF_UNITS in the CBUFF driver implementation). If this threshold condition is violated, the CBUFF driver will return an error during configuration and the demo will generate a fatal exception as a result. When HSI header is enabled, the total transfer size is ensured to be at least 256 bytes, which satisfies the minimum. If HSI header is disabled, for the HW session, this means that numAdcSamples * numRxChannels * 4 &gt;= 64. Although mmwavelink allows minimum number of ADC samples to be 2, the demo is supported for numAdcSamples &gt;= 64. So HSI header is not required to be enabled for HW only case. But if SW session is enabled, without the HSI header, the bytes in each packet will be 8 + Nd * 20. So for frames/sub-frames where Nd &lt; 3, the demo will generate exception. Therefore HSI header must be enabled if SW is enabled, this is checked in the CLI command validation.</li>
</ol>
<h2><a class="anchor" id="lvdsImpl"></a>
Implementation Notes</h2>
<ol type="1">
<li>The LVDS implementation is mostly present in <a class="el" href="mmw__lvds__stream_8h.html" title="LVDS stream header file. ">mmw_lvds_stream.h</a> and <a class="el" href="mmw__lvds__stream_8c.html" title="Implements LVDS stream functionality. ">mmw_lvds_stream.c</a> with calls in <a class="el" href="mss__main_8c.html" title="This is the main file which implements the millimeter wave Demo. ">mss_main.c</a>. Additionally HSI clock initialization is done at first time sensor start using <a class="el" href="mss__main_8c.html#a95b554e7d257c8e22bd722392281510c">MmwDemo_mssSetHsiClk</a>.</li>
<li>EDMA channel resources for CBUFF/LVDS are in the global resource file (<a class="el" href="mmw__res_8h.html" title="Defines partitioning of hardware resources (EDMA etc) among the DPCs and other components in the mill...">mmw_res.h</a>, see <a class="el" href="index.html#resourceAlloc">Hardware Resource Allocation</a>) along with other EDMA resource allocation. The user data header and two user payloads are configured as three user buffers in the CBUFF driver. Hence SW allocation for EDMA provides for three sets of EDMA resources as seen in the SW part (swSessionEDMAChannelTable[.]) of <a class="el" href="mmw__lvds__stream_8c.html#a37e197443bf8362978f18986a3d587f7">MmwDemo_LVDSStream_EDMAInit</a>. The maximum number of HW EDMA resources are needed for the data-format <a class="el" href="mmw__config_8h.html#a9d2321accdcaa9ea590295cf655bd421">MMW_DEMO_LVDS_STREAM_CFG_DATAFMT_CP_ADC_CQ</a>, which as seen in the corresponding slide in ti\drivers\cbuff\docs\CBUFF_Transfers.pptx is 12 channels (+ shadows) including the 1st special CBUFF EDMA event channel which CBUFF IP generates to the EDMA, hence the HW part (hwwSessionEDMAChannelTable[.]) of <a class="el" href="mmw__lvds__stream_8c.html#a37e197443bf8362978f18986a3d587f7">MmwDemo_LVDSStream_EDMAInit</a> has 11 table entries.</li>
<li>Although the CBUFF driver is configured for two sessions (hw and sw), at any time only one can be active. So depending on the LVDS CLI configuration and whether advanced frame or not, there is logic to activate/deactivate HW and SW sessions as necessary.</li>
<li>The CBUFF session (HW/SW) configure-create and delete depends on whether or not re-configuration is required after the first time configuration.<ol type="a">
<li>For HW session, re-configuration is done during sub-frame switching to re-configure for the next sub-frame but when there is no advanced frame (number of sub-frames = 1), the HW configuration does not need to change so HW session does not need to be re-created.</li>
<li>For SW session, even though the user buffer start addresses and sizes of headers remains same, the number of detected objects which determines the sizes of some user buffers changes from one sub-frame/frame to another sub-frame/frame. Therefore SW session needs to be recreated every sub-frame/frame.</li>
</ol>
</li>
<li>User may modify the application software to transmit different information than point-cloud in the SW data e.g radar cube data (output of range DPU). However the CBUFF also has a maximum link list entry size limit of 0x3FFF CBUFF units or 32766 bytes. This means it is the limit for each user buffer entry [there are maximum of 3 entries -1st used for user data header, 2nd for point-cloud and 3rd for point-cloud side information]. During session creation, if this limit is exceeded, the CBUFF will return an error (and demo will in turn generate an exception). A single physical buffer of say size 50000 bytes may be split across two user buffers by providing one user buffer with (address, size) = (start address, 25000) and 2nd user buffer with (address, size) = (start address + 25000, 25000), beyond this two (or three if user data header is also replaced) limit, the user will need to create and activate (and wait for completion) the SW session multiple times to accomplish the transmission.</li>
</ol>
<p>The following figure shows a timing diagram for the LVDS streaming (the figure is not to scale as actual durations will vary based on configuration).</p>
<div class="image">
<img src="lvdstiming.png" alt="lvdstiming.png"/>
<div class="caption">
LVDS timing diagram</div></div>
 <h1><a class="anchor" id="bypassCLI"></a>
How to bypass CLI</h1>
<p>Re-implement the file <a class="el" href="mmw__cli_8c.html">mmw_cli.c</a> as follows:</p>
<ol type="1">
<li><a class="el" href="mss__main_8c.html#ab63e6635788b866f59ebf95af6038ad4">MmwDemo_CLIInit</a> should just create a task with input taskPriority. Lets say the task is called "MmwDemo_sensorConfig_task".</li>
<li>All other functions are not needed</li>
<li>Implement the MmwDemo_sensorConfig_task as follows:<ul>
<li>Fill gMmwMssMCB.cfg.openCfg</li>
<li>Fill gMmwMssMCB.cfg.ctrlCfg</li>
<li>Add profiles and chirps using <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/mmwave/docs/mmwave.tag:../../../../../../control/mmwave/docs/doxygen/html/" href="../../../../../../control/mmwave/docs/doxygen/html/group___m_m_w_a_v_e___c_t_r_l___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga324d9c1711b7c6fb27bb09e6872101dd">MMWave_addProfile</a> and <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/mmwave/docs/mmwave.tag:../../../../../../control/mmwave/docs/doxygen/html/" href="../../../../../../control/mmwave/docs/doxygen/html/group___m_m_w_a_v_e___c_t_r_l___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga8ac343747d4c0cf35626630870429b82">MMWave_addChirp</a> functions</li>
<li>Call <a class="el" href="mss__main_8c.html#a1f2d0239181f3286d1f4571a32b1c376">MmwDemo_CfgUpdate</a> for every offset in <a class="el" href="group__config_store_offsets.html">Offsets for storing CLI configuration</a> (MMWDEMO_xxx_OFFSET in <a class="el" href="mmw__mss_8h.html" title="This is the main header file for the Millimeter Wave Demo. ">mmw_mss.h</a>)</li>
<li>Fill gMmwMssMCB.objDetCommonCfg.preStartCommonCfg</li>
<li>Call <a class="el" href="mss__main_8c.html#a451277107eda0cea2260effbd0d0579b">MmwDemo_openSensor</a></li>
<li>Call <a class="el" href="mss__main_8c.html#ae67c9f3e5ebecb63f4617a55e1312926">MmwDemo_configSensor</a></li>
<li>Call <a class="el" href="mss__main_8c.html#a835e769e3aa8644afa7c76afb16614d3">MmwDemo_startSensor</a> (One can use helper function <a class="el" href="mss__main_8c.html#afef2a81fa0c6e880c12a2ead43568cab">MmwDemo_isAllCfgInPendingState</a> to know if all dynamic config was provided)</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="resourceAlloc"></a>
Hardware Resource Allocation</h1>
<p>The Object Detection DPC needs to configure the DPUs hardware resources (EDMA). Even though the hardware resources currently are only required to be allocated for this one and only DPC in the system, the resource partitioning is shown to be in the ownership of the demo. This is to illustrate the general case of resource allocation across more than one DPCs and/or demo's own processing that is post-DPC processing. This partitioning can be seen in the <a class="el" href="mmw__res_8h.html" title="Defines partitioning of hardware resources (EDMA etc) among the DPCs and other components in the mill...">mmw_res.h</a> file. This file is passed as a compiler command line define</p><pre class="fragment">"--define=APP_RESOURCE_FILE="&lt;ti/demo/xwr16xx/mmw/mmw_res.h&gt;" </pre><p> in mmw.mak when building the DPC sources as part of building the demo application and is referred in object detection DPC sources where needed as </p><pre class="fragment">#include APP_RESOURCE_FILE </pre><h1><a class="anchor" id="demoDesignNotes"></a>
Design Notes</h1>
<p>Due to the limitation of DPM local queue size, for certain DPM functions such as <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga0f1dfaf65d819fb330324d5955c64b35">DPM_start</a>, <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#gac00c25a46c276c76147494ba4b0dbf2d">DPM_stop</a> and some of the DPC control through <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2376222b5d5e5dfdabfab4b96da7802b">DPM_ioctl</a>, semaphores are used to sync between calling task and function <a class="el" href="mss__main_8c.html#adcd6ce467b921bea15a436519a1f9614">MmwDemo_DPC_ObjectDetection_reportFxn</a>. So that it won't cause DPM crash because of running out of DPM local queues. The following diagram demonstrates the example calling flow for blocking <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2376222b5d5e5dfdabfab4b96da7802b">DPM_ioctl()</a> function call. Non-blocking <a class="elRef" doxygen="/home/gtbldadm/nightlybuilds/mmwave_sdk/ti/control/dpm/docs/dpm.tag:../../../../../../control/dpm/docs/doxygen/html/" href="../../../../../../control/dpm/docs/doxygen/html/group___d_p_m___e_x_t_e_r_n_a_l___f_u_n_c_t_i_o_n.html#ga2376222b5d5e5dfdabfab4b96da7802b">DPM_ioctl</a> is also shown for comparison.</p>
<div class="image">
<img src="dpm_ioctl_handling.png" alt="dpm_ioctl_handling.png"/>
<div class="caption">
DPM_ioctl calling flow</div></div>
<p> There are DPM report functions on both MSS and DSS for the same DPM_Report. However the sequence is not guaranteed between the two cores.</p>
<h1><a class="anchor" id="memoryUsage"></a>
Memory Usage</h1>
<h2><a class="anchor" id="memUsageSummary"></a>
Memory usage summary</h2>
<p>The table below shows the usage of various memories available on the device across the demo application and other SDK components. The table is generated using the demo's map file and applying some mapping rules to it to generate a condensed summary. The numeric values shown here represent bytes.</p>
<p><b>MSS:</b> For the mapping rules, please refer to <a href="../../demo_mss_mapping.txt">demo_mss_mapping.txt</a>. Refer to the <a href="../../xwr16xx_mmw_demo_mss_mem_analysis_detailed.txt">xwr16xx_mmw_demo_mss_mem_analysis_detailed.txt</a> for detailed analysis of the memory usage across drivers and control/alg components on MSS and to <a href="../../demo_mss_mapping_detailed.txt">demo_mss_mapping_detailed.txt</a> for detailed mapping rules .</p>
<div class="fragment"><div class="line">                                   OVERVIEW                                    </div><div class="line">Memory                              Used               Total        Percent Used</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">DATA_RAM                           57636              196608              29.32%</div><div class="line">HS_RAM                                 0               32768               0.00%</div><div class="line">L3_RAM                                 0              786432               0.00%</div><div class="line">PROG_RAM                          114750              261888              43.82%</div><div class="line">VECTORS                               60                 256              23.44%</div><div class="line"></div><div class="line"></div><div class="line">                            Type           DATA_RAM       HS_RAM       L3_RAM     PROG_RAM      VECTORS</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">APP                         code              16864            0            0        45717           60</div><div class="line">APP                         heap              34816            0            0            0            0</div><div class="line">BIOS                        code                  4            0            0        22443            0</div><div class="line">COMPONENTS_CORE             code               1668            0            0        29996            0</div><div class="line">COMPONENTS_OPTIONAL         code               2236            0            0        15086            0</div><div class="line">linker-generated            linker             2048            0            0          327            0</div><div class="line">linker-generated            unknown               0            0            0         1181            0</div></div><!-- fragment --><p><b>DSS:</b> For the mapping rules, please refer to <a href="../../demo_dss_mapping.txt">demo_dss_mapping.txt</a>. Refer to the <a href="../../xwr16xx_mmw_demo_dss_mem_analysis_detailed.txt">xwr16xx_mmw_demo_dss_mem_analysis_detailed.txt</a> for detailed analysis of the memory usage across drivers and control/alg components on DSS and to <a href="../../demo_dss_mapping_detailed.txt">demo_dss_mapping_detailed.txt</a> for detailed mapping rules .</p>
<div class="fragment"><div class="line">                                   OVERVIEW                                    </div><div class="line">Memory                              Used               Total        Percent Used</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">PAGE 0:</div><div class="line">HSRAM                              32768               32768             100.00%</div><div class="line">L1DSRAM                            16384               16384             100.00%</div><div class="line">L1PSRAM                                0               16384               0.00%</div><div class="line">L2SRAM_UMAP0                      110546              131072              84.34%</div><div class="line">L2SRAM_UMAP1                      131072              131072             100.00%</div><div class="line">L3SRAM                            786432              786432             100.00%</div><div class="line">PAGE 1:</div><div class="line">L3SRAM                                 0              786432               0.00%</div><div class="line"></div><div class="line"></div><div class="line">                            Type              HSRAM      L1DSRAM      L1PSRAM L2SRAM_UMAP0 L2SRAM_UMAP1       L3SRAM</div><div class="line">--------------------------------------------------------------------------------</div><div class="line">ALG                         code                  0            0            0         2528        12320            0</div><div class="line">APP                         code                  0            0            0        24723        18080            0</div><div class="line">APP                         heap              32768        16384            0        70664            0       786432</div><div class="line">BIOS                        code                  0            0            0         5456        44224            0</div><div class="line">COMPONENTS_CORE             code                  0            0            0         5119        56448            0</div><div class="line">linker-generated            linker                0            0            0         2056            0            0</div></div><!-- fragment --> </div></div><!-- contents -->
<hr size="1"><small>
Copyright  2019, Texas Instruments Incorporated</small>
</body>
</html>
